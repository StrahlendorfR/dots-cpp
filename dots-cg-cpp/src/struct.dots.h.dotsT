#pragma once
// This file was generated by the DOTS code generator. Do not change!

#include <dots/type/FundamentalTypes.h>
#include <dots/type/StaticStruct.h>
#include <dots/type/StaticProperty.h>
#include <dots/type/StaticPropertyOffset.h>
{% for imp in imports %}
#include "{{imp}}.dots.h"
{% endfor %}
{% for inc in includes %}
#include "{{inc}}"
{% endfor %}

{% if (options is defined and 'deprecated' in options) or (attributes | selectattr("options", "defined") | selectattr("options.deprecated", "defined") | list | length > 0) %}
#if (defined _MSC_VER)
#pragma warning(push)
#pragma warning(disable: 4996)
#elif (defined __GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

{% endif %}
namespace dots::types
{
    namespace details
    {
        struct Proto{{name}} : type::details::ProtoStaticStruct
        {
{% for property in attributes %}
            type::details::ProtoStaticProperty<types::{{property.cxx_type}}> {{property.name}};
{% endfor %}
        };
    }

{% for comment_line in structComment %}
    /// {{comment_line}}
{% endfor %}
    ///
{% for property in attributes %}
    /// @param {% if property.key %}[key] {% endif %}{{property.name}} {% if property.options is defined and 'deprecated' in property.options %}[DEPRECATED] {% endif %}{{property.comment}}
{% endfor %}
    ///
    /// @code
    /// Structure {
{% for property in attributes %}
    ///    {{property.tag}}: {% if property.key %}[key] {% endif %}{{property.type}} {{property.name}} // {% if property.options is defined and 'deprecated' in property.options %}[DEPRECATED] {% endif %}{{property.comment}}
{% endfor %}
    /// }
    /// @endcode
    {% if options is defined and 'deprecated' in options %}
    #if (!defined DOTS_ACKNOWLEDGE_DEPRECATION_OF_{{name}})
    struct [[deprecated]] {{name}} : type::StaticStruct<{{name}}>
    #else
    struct {{name}} : type::StaticStruct<{{name}}>
    #endif
    {% else %}
    struct {{name}} : type::StaticStruct<{{name}}>
    {% endif %}
    {
        static constexpr std::string_view _Name = "{{name}}";

        static constexpr uint8_t _Cached        = {% if options.cached %}true{% else %}false{% endif %};
        static constexpr uint8_t _Internal      = {% if options.internal %}true{% else %}false{% endif %};
        static constexpr uint8_t _Persistent    = {% if options.persistent %}true{% else %}false{% endif %};
        static constexpr uint8_t _Cleanup       = {% if options.cleanup %}true{% else %}false{% endif %};
        static constexpr uint8_t _Local         = {% if options.local %}true{% else %}false{% endif %};
        static constexpr uint8_t _SubstructOnly = {% if options.substruct_only %}true{% else %}false{% endif %};

{% for property in attributes %}
        struct {{property.name}}_pt : type::StaticProperty<types::{{property.cxx_type}}, {{property.name}}_pt>
        {
            using struct_t = {{name}};
            #if (defined DOTS_PROPERTIES_NO_CONSTEXPR_OFFSETS)
            inline static auto Metadata = []()
            { 
                auto proto{{name}} = details::Proto{{name}}{};
                return type::StaticPropertyMetadata{ "{{property.name}}", {{property.tag}}, {% if property.key %}true{% else %}false{% endif %}, type::StaticPropertyOffset::MakeOffset(&proto{{name}}._propertyArea, &proto{{name}}.{{property.name}}) };
            }();
            #else
            inline static constexpr auto Metadata = []()
            { 
                constexpr auto proto{{name}} = details::Proto{{name}}{};
                return type::StaticPropertyMetadata{ "{{property.name}}", {{property.tag}}, {% if property.key %}true{% else %}false{% endif %}, type::StaticPropertyOffset::MakeOffset(&proto{{name}}._propertyArea, &proto{{name}}.{{property.name}}) };
            }();
            #endif

            {{property.name}}_pt& operator = (const {{property.name}}_pt& rhs) = default;
            {{property.name}}_pt& operator = ({{property.name}}_pt&& rhs) = default;

            #if (defined DOTS_EXPERIMENTAL_DESIGNATED_STRUCT_INITIALIZATION)
            using StaticProperty::StaticProperty;
            {{property.name}}_pt() = default;
            ~{{property.name}}_pt() = default;
            #endif

            {% if property.vector %}
            {{property.name}}_pt(std::initializer_list<types::{{property.cxx_vector_type}}> init)
            {
                StaticProperty::emplace(init);
            }

            {% endif %}
            using StaticProperty::operator=;

        private:

            friend {{name}};

            #if (!defined DOTS_EXPERIMENTAL_DESIGNATED_STRUCT_INITIALIZATION)
            {{property.name}}_pt() = default;
            ~{{property.name}}_pt() = default;
            #endif
            {{property.name}}_pt(const {{property.name}}_pt& other) = default;
            {{property.name}}_pt({{property.name}}_pt&& other) = default;
        };
        static constexpr types::property_set_t {{property.name}}_p = types::property_set_t::FromIndex({{property.tag}});

{% endfor %}
        using _key_properties_t = std::tuple<{% for property in keyAttributes %}{{property.name}}_pt*{% if not loop.last %}, {% endif %}{% endfor %}>;
        using _properties_t     = std::tuple<{% for property in attributes %}{{property.name}}_pt*{% if not loop.last %}, {% endif %}{% endfor %}>;

        #if (!defined DOTS_EXPERIMENTAL_DESIGNATED_STRUCT_INITIALIZATION)
        {% for property in attributes %}
        using {{property.name}}_i = type::PropertyInitializer<{{property.name}}_pt>;
        {% endfor %}

        {{name}}() = default;
        {{name}}(const {{name}}& other) = default;
        {{name}}({{name}}&& other) = default;
        ~{{name}}() = default;

        {{name}}& operator = (const {{name}}& rhs) = default;
        {{name}}& operator = ({{name}}&& rhs) = default;

        template <typename... PropertyInitializers, std::enable_if_t<sizeof...(PropertyInitializers) >= 1 && std::conjunction_v<type::is_property_initializer_t<std::remove_pointer_t<std::decay_t<PropertyInitializers>>>...>, int> = 0>
        {{name}}(PropertyInitializers&&... propertyInitializers)
        {
            (_getProperty<typename std::remove_pointer_t<std::decay_t<PropertyInitializers>>::property_t>().emplace(std::forward<decltype(propertyInitializers)>(propertyInitializers).value), ...);
        }
        #endif

        template <typename P>
        const P& _getProperty() const
        {
            {% for property in attributes %}
            {% if not loop.first %}else {% endif %}if constexpr (std::is_same_v<P, {{property.name}}_pt>)
            {
                return {{property.name}};
            }
            {% endfor %}
            else
            {
                static_assert(std::is_same_v<P, void>, "P is not a property of struct type {{name}}");
            }
        }

        template <typename P>
        P& _getProperty()
        {
            return const_cast<P&>(std::as_const(*this).template _getProperty<P>());
        }

{% for property in attributes %}
        {% if property.options is defined and 'deprecated' in property.options %}
        #if (!defined DOTS_ACKNOWLEDGE_DEPRECATION_OF_{{name}}_{{property.name}})
        [[deprecated]]
        #endif
        {{property.name}}_pt {{property.name}}; // [DEPRECATED] {{property.tag}}: {% if property.key %}[key] {% endif %}{{property.type}} {{property.name}} // [DEPRECATED] {{property.comment}}
        {% else %}
        {{property.name}}_pt {{property.name}}; // {{property.tag}}: {% if property.key %}[key] {% endif %}{{property.type}} {{property.name}} // {{property.comment}}
        {% endif %}
{% endfor %}
    };
}

namespace dots::type
{
    template <>
    struct Descriptor<types::{{name}}> : StructDescriptor
    {
        Descriptor(key_t key) :
            StructDescriptor(key, std::string{ types::{{name}}::_Name }, {% if options.cached %}Cached{% else %}Uncached{% endif %}{% if options.internal %} | Internal{% endif %}{% if options.persistent %} | Persistent{% endif %}{% if options.cleanup %} | Cleanup{% endif %}{% if options.local %} | Local{% endif %}{% if options.substruct_only %} | SubstructOnly{% endif %}, types::{{name}}::_MakePropertyDescriptors(), sizeof(Descriptor<types::{{name}}>*), sizeof(types::{{name}}), alignof(types::{{name}})){}

        const PropertyArea& propertyArea(const Struct& instance) const override
        {
            return StructDescriptor::propertyArea(static_cast<const types::{{name}}&>(instance));
        }

        PropertyArea& propertyArea(Struct& instance) const override
        {
            return StructDescriptor::propertyArea(static_cast<types::{{name}}&>(instance));
        }

        static const PropertyArea& propertyArea(const types::{{name}}& instance)
        {
            return instance._propertyArea();
        }

        static PropertyArea& propertyArea(types::{{name}}& instance)
        {
            return instance._propertyArea();
        }

        static auto& Instance()
        {
            return InitInstance<types::{{name}}>();
        }
    };
}

#if (!defined DOTS_TYPES_NO_USING) && (!defined {{name}}_NO_USING)
using dots::types::{{name}};
#endif
{% if (options is defined and 'deprecated' in options) or (attributes | selectattr("options", "defined") | selectattr("options.deprecated", "defined") | list | length > 0) %}
#if (defined _MSC_VER)
#pragma warning(pop)
#elif (defined __GNUG__)
#pragma GCC diagnostic pop
#endif
{% endif %}
