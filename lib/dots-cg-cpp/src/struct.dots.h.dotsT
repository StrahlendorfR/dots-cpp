#pragma once
// This file was generated by the DOTS code generator. Do not change!

#include <dots/type/FundamentalTypes.h>
#include <dots/type/StaticStruct.h>
#include <dots/type/StaticProperty.h>
{% for imp in imports %}
#include "{{imp}}.dots.h"
{% endfor %}
{% for inc in includes %}
#include "{{inc}}"
{% endfor %}

namespace dots::types
{
{% for comment_line in structComment %}
    /// {{comment_line}}
{% endfor %}
    ///
{% for property in attributes %}
    /// @param {{property.name}} {{property.comment}}
{% endfor %}
    ///
    /// @code
    /// Structure {
{% for property in attributes %}
    ///    {{property.tag}}: {{property.type}} {{property.name}} // {{property.comment}}
{% endfor %}
    /// }
    /// @endcode
    struct {{name}} : type::StaticStruct<{{name}}>
    {
		static constexpr const char _Name[] = "{{name}}";

		static constexpr uint8_t _Cached        = {% if options.cached %}true{% else %}false{% endif %};
		static constexpr uint8_t _Internal      = {% if options.internal %}true{% else %}false{% endif %};
		static constexpr uint8_t _Persistent    = {% if options.persistent %}true{% else %}false{% endif %};
		static constexpr uint8_t _Cleanup       = {% if options.cleanup %}true{% else %}false{% endif %};
		static constexpr uint8_t _Local         = {% if options.local %}true{% else %}false{% endif %};
		static constexpr uint8_t _SubstructOnly = {% if options.substruct_only %}true{% else %}false{% endif %};

{% for property in attributes %}
        struct {{property.name}}_t : type::StaticProperty<types::{{property.cxx_type}}, {{property.name}}_t>
        {
			using struct_t = {{name}};
			static constexpr auto Metadata = type::PropertyMetadata<types::{{property.cxx_type}}>{ "{{property.name}}", {{property.tag}}, {% if property.key %}true{% else %}false{% endif %}{% if not loop.first %}, {{loop.previtem.name}}_t::Metadata{% endif %} };
		
			{{property.name}}_t& operator = (const {{property.name}}_t& rhs) = default;
			{{property.name}}_t& operator = ({{property.name}}_t&& rhs) = default;
			using StaticProperty::operator=;

		private:
			friend struct {{name}};

			{{property.name}}_t() = default;
			{{property.name}}_t(const {{property.name}}_t& other) = default;
			{{property.name}}_t({{property.name}}_t&& other) = default;
			~{{property.name}}_t() = default;
        };
		using {{property.name}}_i = type::PropertyInitializer<{{property.name}}_t, types::{{property.cxx_type}}>;
		static constexpr types::property_set_t {{property.name}}_p = types::property_set_t::FromIndex({{property.tag}});

{% endfor %}
        using _key_properties_t = std::tuple<{% for property in keyAttributes %}{{property.name}}_t*{% if not loop.last %}, {% endif %}{% endfor %}>;
        using _properties_t     = std::tuple<{% for property in attributes %}{{property.name}}_t*{% if not loop.last %}, {% endif %}{% endfor %}>;

		{{name}}() = default;
		{{name}}(const {{name}}& other) = default;
		{{name}}({{name}}&& other) = default;
		~{{name}}() = default;

		{{name}}& operator = (const {{name}}& rhs) = default;
		{{name}}& operator = ({{name}}&& rhs) = default;

		template <typename... PropertyInitializers, std::enable_if_t<sizeof...(PropertyInitializers) >= 1 && std::conjunction_v<type::is_property_initializer_t<std::remove_pointer_t<std::decay_t<PropertyInitializers>>>...>, int> = 0>
		explicit {{name}}(PropertyInitializers&&... propertyInitializers)
		{
			(_getProperty<typename std::remove_pointer_t<std::decay_t<PropertyInitializers>>::property_t>().template construct<false>(std::forward<decltype(propertyInitializers)>(propertyInitializers).value), ...);
		}

		template <typename P>
		const P& _getProperty() const
		{
			{% for property in attributes %}
			{% if not loop.first %}else {% endif %}if constexpr (std::is_same_v<P, {{property.name}}_t>)
			{
				return {{property.name}};
			}
			{% endfor %}
			else
			{
				static_assert(std::is_same_v<P, void>, "P is not a property of struct type {{name}}");
			}
		}

		template <typename P>
		P& _getProperty()
		{
			return const_cast<P&>(std::as_const(*this).template _getProperty<P>());
		}

{% for property in attributes %}
        {{property.name}}_t {{property.name}}; // {{property.comment}} (key: {{property.key | lower }})
{% endfor %}
    };
}

namespace dots::type
{
	template <>
	struct Descriptor<types::{{name}}> : StructDescriptor<types::{{name}}>
	{
		Descriptor() :
			StructDescriptor(types::{{name}}::_Name, {% if options.cached %}Cached{% else %}Uncached{% endif %}{% if options.internal %} | Internal{% endif %}{% if options.persistent %} | Persistent{% endif %}{% if options.cleanup %} | Cleanup{% endif %}{% if options.substruct_only %} | SubstructOnly{% endif %}, types::{{name}}::_MakePropertyDescriptors()){}
	};
}

#if (!defined DOTS_TYPES_NO_USING) && (!defined {{name}}_NO_USING)
using dots::types::{{name}};
#endif