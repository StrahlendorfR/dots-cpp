#pragma once
// This file was generated by the DOTS code generator. Do not change!

#include <dots/type/NewFundamentalTypes.h>
#include <dots/type/NewStaticStruct.h>
#include <dots/type/NewStaticProperty.h>
{% for imp in imports %}
#include "{{imp}}.dots.h"
{% endfor %}
{% for inc in includes %}
#include "{{inc}}"
{% endfor %}

namespace dots::types
{
{% for comment_line in structComment %}
    /// {{comment_line}}
{% endfor %}
    ///
{% for property in attributes %}
    /// @param {{property.name}} {{property.comment}}
{% endfor %}
    ///
    /// @code
    /// Structure {
{% for property in attributes %}
    ///    {{property.tag}}: {{property.type}} {{property.name}} // {{property.comment}}
{% endfor %}
    /// }
    /// @endcode
    struct {{name}} : type::StaticStruct<{{name}}>
    {
		static constexpr const char _Name[] = "{{name}}";

		static constexpr uint8_t _Cached        = {% if options.cached %}true{% else %}false{% endif %};
		static constexpr uint8_t _Internal      = {% if options.internal %}true{% else %}false{% endif %};
		static constexpr uint8_t _Persistent    = {% if options.persistent %}true{% else %}false{% endif %};
		static constexpr uint8_t _Cleanup       = {% if options.cleanup %}true{% else %}false{% endif %};
		static constexpr uint8_t _Local         = {% if options.local %}true{% else %}false{% endif %};
		static constexpr uint8_t _SubstructOnly = {% if options.substruct_only %}true{% else %}false{% endif %};

{% for property in attributes %}
        struct {{property.name}}_t : type::StaticProperty<types::{{property.cxx_type}}, {{property.name}}_t>
        {
			using struct_t = {{name}};
			inline static auto Descriptor = type::PropertyDescriptor<types::{{property.cxx_type}}>{ "{{property.name}}"{% if not loop.first %}, {{loop.previtem.name}}_t::Descriptor{% endif %}, {{property.tag}}, {% if property.key %}true{% else %}false{% endif %} };
		
			{{property.name}}_t& operator = (const {{property.name}}_t& rhs) = default;
			{{property.name}}_t& operator = ({{property.name}}_t&& rhs) = default;
			using StaticProperty::operator=;

		private:
			friend struct {{name}};

			{{property.name}}_t() = default;
			{{property.name}}_t(const {{property.name}}_t& other) = default;
			{{property.name}}_t({{property.name}}_t&& other) = default;
			~{{property.name}}_t() = default;
        };
		using {{property.name}}_i = type::TPropertyInitializer<{{property.name}}_t, types::{{property.cxx_type}}>;
		static constexpr types::property_set_t {{property.name}}_p = types::property_set_t::FromIndex({{property.tag}});

{% endfor %}
        using _key_properties_t = std::tuple<{% for property in keyAttributes %}{{property.name}}_t*{% if not loop.last %}, {% endif %}{% endfor %}>;
        using _properties_t     = std::tuple<{% for property in attributes %}{{property.name}}_t*{% if not loop.last %}, {% endif %}{% endfor %}>;

		using StaticStruct::StaticStruct;
		{{name}}(const {{name}}& other) = default;
		{{name}}({{name}}&& other) = default;
		~{{name}}() = default;

		{{name}}& operator = (const {{name}}& rhs) = default;
		{{name}}& operator = ({{name}}&& rhs) = default;        

{% for property in attributes %}
        {{property.name}}_t {{property.name}}; // {{property.comment}} (key: {{property.key | lower }})
{% endfor %}
    };
}

namespace dots::type
{
	template <>
	struct Descriptor<types::{{name}}> : StructDescriptor<types::{{name}}>
	{
		Descriptor() :
			StructDescriptor(types::{{name}}::_Name, types::{{name}}::_Cached | types::{{name}}::_Internal | types::{{name}}::_Persistent | types::{{name}}::_Cleanup | types::{{name}}::_Local | types::{{name}}::_SubstructOnly, {
{% for property in attributes %}
                &types::{{name}}::{{property.name}}_t::Descriptor{% if not loop.last %},{% endif %}
				
{% endfor %}
			}){}
	};
}

#if (!defined DOTS_TYPES_NO_USING) && (!defined {{name}}_NO_USING)
using dots::types::{{name}};
#endif