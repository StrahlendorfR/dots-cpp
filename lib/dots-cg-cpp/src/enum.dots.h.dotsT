#pragma once
// This file was generated by the DOTS code generator. Do not change!
#include <dots/type/Enum.h>
#include "EnumDescriptorData.dots.h"

{% for inc in includes %}
#include "{{inc}}"
{% endfor %}

namespace dots::types
{
    /// {{comment}}
    ///
    /// @code
    {% for elem in items %}
    /// {{elem.name}} = {{elem.value}} ({{elem.comment}})
    {% endfor %}
    /// @endcode
    enum class {{name}} : int32_t
    {
    {% for elem in items %}
        {{elem.name}} = {{elem.value}}, ///< {{elem.comment}}
    {% endfor %}
    };
}

namespace dots::type
{
    template <>
    struct Enum<types::{{name}}> : Enum<>
    {
        using value_t = types::{{name}};
        
        Enum(value_t enumerator) : Enum<>{ Descriptor(), static_cast<std::underlying_type_t<value_t>>(enumerator) }
        {
            /* do nothing */
        }

        static const EnumDescriptor& Descriptor()
        {
            static const EnumDescriptor* enumDescriptor = dynamic_cast<const EnumDescriptor*>(Descriptor::registry().findDescriptor("{{name}}"));

            if (enumDescriptor == nullptr)
            {
                // allocate space for descriptor to avoid recursive descriptor construction issues
                static std::aligned_storage_t<sizeof(EnumDescriptor), alignof(EnumDescriptor)> enumDescriptorStorage;
                enumDescriptor = reinterpret_cast<const EnumDescriptor*>(&enumDescriptorStorage);

                EnumDescriptorData enumDescriptorData{ EnumDescriptorData::name_i{ "{{name}}" } };
                Vector<EnumElementDescriptor>& enumeratorDescriptorData = enumDescriptorData.elements();

                {% for elem in items %}
                enumeratorDescriptorData.emplace_back(
                    EnumElementDescriptor::enum_value_i{ static_cast<std::underlying_type_t<value_t>>(types::{{name}}::{{elem.name}}) },
                    EnumElementDescriptor::name_i{ "{{elem.name}}" },
                    EnumElementDescriptor::tag_i{ {{elem.tag}} }
                );
                
                {% endfor %}
                EnumDescriptor::createFromEnumDescriptorData(enumDescriptorData, reinterpret_cast<EnumDescriptor*>(&enumDescriptorStorage));
            }

            return *enumDescriptor;
        }
    };
}

#if (!defined DOTS_TYPES_NO_USING) && (!defined {{name}}_NO_USING)
using dots::types::{{name}};
#endif
